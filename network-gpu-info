#!/bin/sh
# By Jon Dehdari, 2016
# See README.md for details

set -o nounset # Don't allow unused variables

usage='Usage:
   ./network-gpu-info  [options]  hosts.txt
   ./network-gpu-info  [options]  [[user@]remote1 [[user@]remote2 [...]]]

Options:
  -l, --loop [n]     Continuously display results every n seconds (default: 5)
      --timeout <n>  Set SSH timeout to n seconds (default: 2)
  -h, --help         Show this help info
'

# Defaults
cmd="nvidia-smi --query-gpu=utilization.gpu --format=csv,noheader,nounits"
loop=''
timeout=2
num_regex='^[0-9]+$'

### Process command-line args
### If not enough arguments, die
if [ $# -lt 1 ]; then
	echo "$usage"
	exit
fi

while [ $# -ge 1 ]; do
    case $1 in
    -l | --loop)
		case $2 in  # is the next argument a number?
			''|[0-9]*)
				# If so, take next arg as value of $loop
				loop=$2
				shift 2;;
			*)
				# Next arg is not a number, so use default
				loop=5
				shift;;
		esac
        ;;
	--timeout)
		timeout=$2
		shift 2
		;;
    -h | --help)
        echo "$usage"
        exit
        ;;
    -*)
        echo 'Warning: invalid flag'
        echo "$usage"
        shift
        ;;
    *)
        break
        ;;
    esac
done
hosts_arg=$*


# Is the output a terminal?
is_terminal=''
if test -t 1; then
	export is_terminal=1
fi


hostname_escape() {
	# We're using a Posix-shell compliant hash table based on variables, so we
	# need to escape '@' and '.' in hostnames.
	sed 's/\./__dot__/g; s/@/__at__/g'
}

hostname_unescape() {
	# See docs in hostname_escape()
	sed 's/__dot__/./g; s/__at__/@/g'
}

# Portable hash table in bourne shell
# Bash 4 natively supports hash tables
# https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash
hput() {
	escaped_hostname=$(echo $2 | hostname_escape )
	eval "$1"__"$escaped_hostname"='$3'
}

hget() {
	escaped_hostname=$(echo $2 | hostname_escape)
	eval echo '${'"$1__$escaped_hostname"'#hash}'
}

visualize() {
	stats=$1
	shift
	hosts=$*
	#host=$1
	#card_info=$2

	for host in $hosts; do
		card_info=$(hget $stats $host)
		if [ $is_terminal ]; then
	
			# Print host
			tput bold
			echo "$host:"
			tput sgr0 # Reset it to normal colors
	
			card_num=0
			for card in $card_info; do
				printf " %2s %3s%%: [" $card_num $card
				# Cut value in half for shorter visualized line
				card=$(($card / 2))
				tput bold
				tput setaf 2  # Lower third is green
				for tick in $(seq 0 1 $card); do
					if [ $tick -eq 17 ]; then # Middle third is yellow
						tput setaf 3 # Yellow
					elif [ $tick -eq 34 ]; then # Upper third is red
						tput setaf 1 # Red
					fi
					printf "|"
				done
				tput sgr0 # Reset it to normal colors
				# Complementing spaces
				for tick in $(seq $card 1 50); do
					printf " "
				done
				printf "]\n"
				card_num=$((card_num+1))
			done
			printf "\n"
		else
			# Output is not a terminal
			echo "$host:"
			printf "$card_info\n\n"
		fi
	done
}


# Process command-line hosts-related argument.  It can either be a list of hosts,
# or a text file of hosts. Returns a string containing hosts.
get_hosts() {
	hosts_arg=$*
	hosts=''
	host_id=1

	# If command-line argument is a regular file, process each line in it
	if [ -f "$hosts_arg" ]; then
		while read host; do
			case $host in ''|\#*) continue;; esac  # skip commented out lines
			hosts="$hosts $host"
		done < $hosts_arg
		printf "$hosts"
	else
		# Otherwise assume command-line arguments are a list of hosts
		printf "$hosts_arg"
	fi
}


get_stats() {
	stats=$1
	shift
	hosts=$*

	for host in $hosts; do
		if [ $host = 'localhost' ]; then # Don't bother with SSH for localhost
			card_info=$($cmd)
		else
			card_info=$(ssh -n -o ConnectTimeout=$timeout  $host $cmd)
		fi
		#visualize "$host" "$card_info"
		hput "$stats" "$host" "$card_info"
	done
}


# Main
hosts=$(get_hosts $hosts_arg)
# Do the following once (in the absence of a do-while loop in sh)
get_stats stats $hosts
visualize stats $hosts

while [ $loop ]; do
	tput setaf 8 # Grey
	echo 'ctrl-c to quit' >&2
	tput sgr0 # Reset it to normal colors
	sleep $loop
	clear
	get_stats stats $hosts
	visualize stats $hosts
done
