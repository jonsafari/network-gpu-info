#!/bin/sh
# By Jon Dehdari, 2016
# See README.md for details

set -o nounset # Don't allow unused variables

usage='Usage:
   ./network-gpu-info  [options]  hosts.txt
   ./network-gpu-info  [options]  [[user@]remote1 [[user@]remote2 [...]]]

Options:
  -l, --loop [n]     Continuously display results every n seconds (default: 5)
      --timeout <n>  Set SSH timeout to n seconds (default: 2)
  -h, --help         Show this help info
'

# Defaults
nv_cmd="nvidia-smi --query-gpu=utilization.gpu --format=csv,noheader,nounits"
cl_cmd="tbd"
cmd=${nv_cmd}
loop=''
timeout=2
num_regex='^[0-9]+$'
tmpfile='/tmp/network-gpu-info'

### Process command-line args
### If not enough arguments, die
if [ $# -lt 1 ]; then
	echo "$usage"
	exit
fi

while [ $# -ge 1 ]; do
    case $1 in
    -l | --loop)
		case $2 in  # is the next argument a number?
			''|[0-9]*)
				# If so, take next arg as value of $loop
				loop=$2
				shift 2;;
			*)
				# Next arg is not a number, so use default
				loop=5
				shift;;
		esac
        ;;
	--timeout)
		timeout=$2
		shift 2
		;;
    -h | --help)
        echo "$usage"
        exit
        ;;
    -*)
        echo 'Warning: invalid flag'
        echo "$usage"
        shift
        ;;
    *)
        break
        ;;
    esac
done
hosts_arg=$*


# Is the output a terminal?
is_terminal=''
if test -t 1; then
	export is_terminal=1
fi


hostname_escape() {
	# We're using a Posix-shell compliant hash table based on variables, so we
	# need to escape '@' and '.' in hostnames.
	sed 's/\./__dot__/g; s/@/__at__/g; s/-/__hyphen__/g'
}

hostname_unescape() {
	# See docs in hostname_escape()
	sed 's/__dot__/./g; s/__at__/@/g; s/__hyphen__/-/g'
}

# Portable hash table in bourne shell
# Bash 4 natively supports hash tables
# https://stackoverflow.com/questions/1494178/how-to-define-hash-tables-in-bash
hformat() {
	# $1 is hash table
	# $2 is key (hostname)
	# $3 is value
	escaped_hostname=$(echo $2 | hostname_escape )
	echo "$1"__"$escaped_hostname"="'$3'"
}
hput() {
	eval $(hformat $1 $2 $3)
}

hget() {
	escaped_key=${1}__$(echo $2 | hostname_escape)
	if [ ! -z ${escaped_key+x} ]; then  # ensure that variable is bound
		eval echo '${'"$escaped_key"'#hash}'
	fi
}

visualize() {
	stats=$1
	shift
	hosts=$*

	for host in $hosts; do
		card_info=$(hget $stats $host)
		if [ $is_terminal ]; then
	
			# Print host
			tput bold
			echo "$host:"
			tput sgr0 # Reset it to normal colors
	
			card_num=0
			for card in $card_info; do
				printf " %2s %3s%%: [" $card_num $card
				# Cut value in half for shorter visualized line
				card=$(($card / 2))
				tput bold
				tput setaf 2  # Lower third is green
				for tick in $(seq 0 1 $card); do
					if [ $tick -eq 17 ]; then # Middle third is yellow
						tput setaf 3 # Yellow
					elif [ $tick -eq 34 ]; then # Upper third is red
						tput setaf 1 # Red
					fi
					printf "|"
				done
				tput sgr0 # Reset it to normal colors

				# Complementing spaces
				complement=$(( 50 - $card ))
				printf "%${complement}s]\n"

				card_num=$((card_num+1))
			done
			printf "\n"
		else
			# Output is not a terminal
			echo "$host:"
			printf "$card_info\n\n"
		fi
	done
}


# Process command-line hosts-related argument.  It can either be a list of hosts,
# or a text file of hosts. Returns a string containing hosts.
get_hosts() {
	hosts_arg=$*
	hosts=''
	host_id=1

	# If command-line argument is a regular file, process each line in it
	if [ -f "$hosts_arg" ]; then
		while read host; do
			case $host in ''|\#*) continue;; esac  # skip commented out lines
			hosts="$hosts $host"
		done < $hosts_arg
		printf "$hosts"
	else
		# Otherwise assume command-line arguments are a list of hosts
		printf "$hosts_arg"
	fi
}


get_stats() {
	stats=$1
	shift
	hosts=$*

	for host in $hosts; do
		# Sort buffers output until EOF, to reduce race conditions
		if [ $host = 'localhost' ]; then # Don't bother with SSH for localhost
			{ printf ${stats}__${host}=\'; $cmd | tr '\n' ' ' && printf "'\n"; } | sort &
		else
			{ \ssh -n -o ConnectTimeout=$timeout  $host "printf ${stats}__${host}=\'; $cmd" | tr '\n' ' ' && printf "'\n"; } | sort &
		fi
	done | hostname_escape > $tmpfile
	wait
	. $tmpfile
}


# Main
hosts=$(get_hosts $hosts_arg)
# Do the following once (in the absence of a do-while loop in sh)
touch $tmpfile
get_stats stats $hosts
visualize stats $hosts

while [ $loop ]; do
	tput setaf 8 # Grey
	echo 'ctrl-c to quit' >&2
	tput sgr0 # Reset it to normal colors
	sleep $loop
	get_stats stats $hosts
	clear
	visualize stats $hosts
done

\rm $tmpfile
